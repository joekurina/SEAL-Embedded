// fft.cpp
// Compiled as C++ but implements the same functions from fft.h
// bridging _Complex double <-> std::complex<double>.

#include "fft.h"    // has "typedef _Complex double fft_complex;"
#include <cassert>  // for assert()
#include <cmath>    // for sin, cos, M_PI
#include <complex.h>  // for C99 complex numbers
#include <vector>   // optional for dynamic arrays

#ifdef __cplusplus
extern "C" {
#endif

#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

// If code calls bitrev(...) from outside, we must define it here.
size_t bitrev(size_t input, size_t numbits)
{
    // typical 16-bit reversal approach:
    size_t t = (((input & 0xaaaa) >> 1) | ((input & 0x5555) << 1));
    t        = (((t & 0xcccc) >> 2) | ((t & 0x3333) << 2));
    t        = (((t & 0xf0f0) >> 4) | ((t & 0x0f0f) << 4));
    t        = (((t & 0xff00) >> 8) | ((t & 0x00ff) << 8));
    return (numbits == 0) ? 0 : (t >> (16 - numbits));
}

/**
 * Define helper functions to represent the imaginary unit
 * and compute complex conjugate for C style complex numbers.
 */
static inline _Complex double my_I() {
    typedef union { double d[2]; _Complex double c; } conv;
    conv tmp = { { 0.0, 1.0 } };
    return tmp.c;
}

static inline _Complex double my_conj(_Complex double z) {
    return __real__(z) - __imag__(z) * my_I();
}

// Basic root calculation using our imaginary unit helper.
static _Complex double calc_root_otf(size_t k, size_t m)
{
    double angle = 2.0 * M_PI * (double)k / (double)m;
    return cos(angle) + my_I() * sin(angle);
}

void calc_fft_roots(size_t n, size_t logn, fft_complex* roots)
{
    assert(n >= 4 && roots);

    size_t m = (n << 1);
    for (size_t i = 0; i < n; i++)
    {
        // original approach: bit-reverse i if that's the storage scheme
        size_t br = bitrev(i, logn);
        roots[i] = calc_root_otf(br, m);
    }
}

void calc_ifft_roots(size_t n, size_t logn, fft_complex* ifft_roots)
{
    assert(n >= 4 && ifft_roots);

    size_t m = (n << 1);
    for (size_t i = 0; i < n; i++)
    {
        // conj of the forward root at (i - 1), or bitreversed logic if needed
        ifft_roots[i] = my_conj(calc_root_otf((i - 1), m));
    }
}

void ifft_inpl(fft_complex* vec, size_t n, size_t logn, const fft_complex* roots)
{
    // reset root index each call
    size_t root_idx = 1;

    // 3) do the IFFT logic
    // For the "Harvey butterfly," we do:
    //   s = conj( calc_root_otf(bitrev(h + j, logn), 2n ) )  if OTF
    //   s = r[root_idx++]  if one-shot or load-full
    size_t tt = 1, h = n / 2;
    for (size_t round = 0; round < logn; round++, tt *= 2, h /= 2)
    {
        for (size_t j = 0, kstart = 0; j < h; j++, kstart += 2*tt)
        {
            _Complex double s;
            if (roots) 
            {
                // "one-shot" approach
                s = roots[root_idx++];
            }
            else
            {
                // "on-the-fly" approach
                size_t br = bitrev(h + j, logn);
                s = my_conj(calc_root_otf(br, n << 1));
            }

            for (size_t k = kstart; k < kstart + tt; k++)
            {
                _Complex double u = vec[k];
                _Complex double w = vec[k + tt];
                vec[k]    = u + w;
                vec[k+tt] = (u - w) * s;
            }
        }
    }
}

void fft_inpl(fft_complex* vec, size_t n, size_t logn, const fft_complex* roots)
{
    // reset root_idx each call
    size_t root_idx = 1;

    // 3) do the FFT logic
    //   s = calc_root_otf(bitrev(h + j, logn), 2n) if OTF
    //   s = r[root_idx++] if one-shot or load-full
    size_t h = 1, tt = n / 2;
    for (size_t round = 0; round < logn; round++, h *= 2, tt /= 2)
    {
        for (size_t j = 0, kstart = 0; j < h; j++, kstart += 2*tt)
        {
            _Complex double s;
            if (roots)
            {
                s = roots[root_idx++];
            }
            else
            {
                size_t br = bitrev(h + j, logn);
                s = calc_root_otf(br, n << 1);
            }

            for (size_t k = kstart; k < kstart + tt; k++)
            {
                _Complex double u = vec[k];
                _Complex double w = vec[k + tt] * s;
                vec[k]    = u + w;
                vec[k+tt] = u - w;
            }
        }
    }
}

#ifdef __cplusplus
} // extern "C"
#endif